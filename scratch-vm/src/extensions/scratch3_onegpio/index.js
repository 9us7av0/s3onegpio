/*
This is the Scratch 3 extension to remotely control an
Arduino Uno, ESP-8666, or Raspberry Pi


 Copyright (c) 2019 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

// Boiler plate from the Scratch
const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
//const formatMessage = require('format-message');


// The following are constants used within the extension

// Digital Modes
const DIGITAL_INPUT = 1;
const DIGITAL_OUTPUT = 2;
const PWM = 3;
const SERVO = 4;
const TONE = 5;
const SONAR = 6;
const ANALOG_INPUT = 7;


// valid pins for the supported boards
const arduino_digital_pins = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
const arduino_analog_pins = [0, 1, 2, 3, 4, 5];
const arduino_pwm_pins = [3, 5, 6, 9, 10, 11];
const esp_8266_digital_pins = [4, 5, 12, 13, 14, 15];
const esp_8266_analog_pins = [0];
const rpi_digital_pins = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
    21, 22, 23, 24, 25, 26, 27];

// an array to save the current pin mode
// this is common to all board types since it contains enough
// entries for all the boards.
// Modes are listed above - initialize to invalid mode of -1
var pin_modes = new Array(30).fill(-1);


// a pointer to pin types - used for all board tyhpes
var the_digital_pins = null;
var the_analog_pins = null;
var the_pwm_pins = null;
var valid = null;

// general message holder
var msg = null;

// the pin assigned to the sonar trigger
// initially set to -1, an illegal value
var sonar_report_pin = -1;

// flag to indicate if the user connected to a board
var connected = false;

// arrays to hold input values
var digital_inputs = new Array(32);
var analog_inputs = new Array(8);

// this array is used to indicate if a pin alert message
// was issued for a block. This prevents an endless loop
// of alerts.
var block_pin_alerts = [0, 0, 0, 0, 0, 0, 0, 0];

// this array is used to indicate if connected alert message
// was issued for a block. This prevents an endless loop
// of alerts.
var connected_alerts = [0, 0, 0, 0, 0, 0, 0];

// was a connect ever attempted?
var connect_attempt = false;


// indices into block_pin_alerts and connected_alerts
const B_DIGITAL_WRITE = 0;
const B_PWM_WRITE = 1;
const B_TONE = 2;
const B_SERVO = 3;
const B_ANALOG_READ = 4;
const B_DIGITAL_READ = 5;
const B_SONAR_READ = 6;

// the current board in use
var the_board = null;

// board ids
var ARDUINO = 1;
var ESP_8266 = 2;
var RPI = 3;

// an array to buffer operations until socket is opened
var wait_open = [];

class Scratch3OneGPIO {
    constructor(runtime) {
        this.runtime = runtime;
        //this.text = "abcde";
        //this.changed = 0;
        //this.lasthat = false;
        this.socket = null;
    }

    getInfo() {
        return {
            id: 'onegpio',
            color1: '#0C5986',
            color2: '#34B0F7',
            name: 'OneGPIO',
            blockIconURI: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnODAiCiAgIHdpZHRoPSIxODAiCiAgIGhlaWdodD0iMTgwIgogICB2aWV3Qm94PSIwIDAgMTgwIDE4MCIKICAgc29kaXBvZGk6ZG9jbmFtZT0ib25lZ3Bpby1zbWFsbC5zdmciCiAgIGlua3NjYXBlOnZlcnNpb249IjAuOTIuNCAoNWRhNjg5YzMxMywgMjAxOS0wMS0xNCkiPgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTg2Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZGVmcwogICAgIGlkPSJkZWZzODQiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxIgogICAgIG9iamVjdHRvbGVyYW5jZT0iMTAiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAiCiAgICAgZ3VpZGV0b2xlcmFuY2U9IjEwIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxODc4IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwMTYiCiAgICAgaWQ9Im5hbWVkdmlldzgyIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTp6b29tPSI0LjY0NDQ0NDQiCiAgICAgaW5rc2NhcGU6Y3g9IjkwIgogICAgIGlua3NjYXBlOmN5PSI5MCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iNDIiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI3IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ic3ZnODAiIC8+CiAgPGltYWdlCiAgICAgd2lkdGg9IjE4MCIKICAgICBoZWlnaHQ9IjE4MCIKICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIgogICAgIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTFFBQUFDMENBWUFBQUE5elFZeUFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFDQmpTRkpOCkFBQjZKZ0FBZ0lRQUFQb0FBQUNBNkFBQWRUQUFBT3BnQUFBNm1BQUFGM0NjdWxFOEFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUEKQjNSSlRVVUg0d1lPQmpBWGE0T09tUUFBU2c1SlJFRlVlTnJ0dlhtWUpVV1o3Lzk1SS9Qc1ZhZlczcXE3NllWVm9MdHBRS0FCMlVTRgpjUmtYUkVmSGNXRis2dUQxdW96NmUzN2oxYm1Pbzg0NGdvN3ppUE00NDRpS1hpK01vNkFJekxpZ1FDOGdBckpEZDlQZDlMNVYxM3JxCkxKbngreU16VDJkbDUzYXFxK28wT08velZHV2V5TWpJeUlodnZ2R05OeUxlRVA1QTVGV3ZldFdrMzFwcmFyVWErWHhlS2FYeUlwSVgKa1U0UldRRE1FNUVCWUlHSTlDcWxTaUppaW9nQXRvaFVSV1JZUlBZQk8wUmtMN0JUS2JWWFJDYTAxaFhidHV1QUxoUUtrNTU3NDQwMwp0cnNvWHRRaTdjN0FiTXNyWC9sS2dLeFNxaXdpL1NLeVhFUk9kLytXdW9EdUVwR0NpT1JFUkpSU0FDSWlPSmhHdStjTkVha0NZeUp5ClFFUzJpOGhHNFBjaThxU0liQWNHYmRzZUxSUUs5dDY5ZTdudHR0dmFYUVF2YW5sUkF2b1ZyM2pGRVdGYWE2V1U2blZCdTFwRVhpb2kKcTBUa0pCSHBFa2RRU3VFQjEvZW5YU0Q3d3lUd3Uza2RhQUM3Uk9SeEVmbWRpRHdBUEFGc0I4WXptY3lrdlAzTHYveEx1NHZzUlNNdgpTa0I3OG9wWHZBS3RkVVlwdFZoRXpnWXVFWkh6bFZJbmlralJBMklReEs1R0RnTjJFN2pCT041NXMyQVBoMmxnTDQ3Vy9vMkkzQ01pCmp4VUtoUU5EUTBOODV6dmZhWGN4dmFqa1JRbG9GOGlHaUp3b0lwZUp5Sld1UnA2cmxKSTRJQWNCR2hZVzk5c0xjNC9hSzJNM3JBNDgKS3lLL0FlNEU3aTJYeXdkMjdkcEZkM2QzOC80YmJyaWgzVVg0Z3BVWEhhQXZ2L3h5QVpZQXIxRkt2ZDZsRjcwZU1QMEFEUXRMK3dmaAoyam5xR0pBRzhMeUkzQzBpLzY2MXZ0c3dqUEY5Ky9aeHl5MjN0THNJWDlEeW9nSDBaWmRkQmxCVVNsMGhJdGVJeURsS3FiNGdOMjRWCjBLMXE2REJOSGZ3dEltaXRBZW9pc2sxRWJnVytCVHhobXFidFh1T3JYLzFxdTR2MUJTZG11ek13RlhIQjI1UjZ2UzRpOGhJUitYOUUKNVBVaWNweHlKQlM4WWVGUklFNmpvZE5xWjM5Y0Y3UVo0SGdSZVI5d1B2Q3ZsbVg5U0NrMUNPaDJsL01MVVY2UUd2cnl5eS9uNFljZgpadVhLbFdpdGkwcXBWNHZJUjBWa3RWSXFGd1JzSElqandPM3YrTVYxRkwzdzRERk9XNGVJMWxydkIyNFhrUytMeUdPQWJSaEdNOEoxCjExM1g3cUkvNXVVRkNlaExMNzBVeTdMRU5NMEZJdkpPRVhtL2lDeFdTa21RUmdRQkhkVVI5TWNCV3RMUzNyRVZNUHMxdGRiYS83c0cKM0M4aW54ZVJYMml0YTRaaFlCZ0dXbXUrK01VdnRydjRqMmw1d1FEYW94bTJiUU1vbDJMOHBWTHFLaEhwTkF3akZaQ1RPSFFTbndaUwpBOXNmSHZYYkx5NE44U3dqbTRBdkE5ODNUWFBRTUF3c3l3TGc3Ly8rNzl0ZEhjZXN2Q0FBZmVtbGx4N09zSWdDemdZK281UzZJb3BTCnhJVzNBdWF3TURjZnFhbUhMKytSNytoMUJBTy9Ed0JmQTc2dWxOcHRtcWIzUWZPRkwzeWgzZFZ5VE1veDN5bjB3S3lVUW11dGdKZUoKeVA4V2tZdWlRQnVtclkrV1R4OU41ekI0SGlkK1lHdXQrNEQvQ1pTMDF2OVlyVmFmTHhhTFRWRC90eHdweHRFbk1iT3lmUGx5RE1OZwpZbUpDRE1PNFFpbjFXWEZHKzFSUTQzcGNNNmloazY1NTEvM0hzR3NpTXVrOHJDVklvL21qV3BDSSsvSWlza0pFdXBSU2o5dTJQYVNVCjRxS0xMdUkzdi9sTnU2dm5tSk1YRXVXNFhFUStwNVE2T3d6TXJmeU8wOTdCNnhEZlFZVG8wY0tFd1JXL1Bib3BBUTN0UDQ0QjM5VmEKZndiWVl4aUdCdmpzWnovYjd1bzVwdVNGUWpuT0VaSC9KU0l0Z1Rrc1BNcWMxd3FYQmhMQjdaYzR1aEYyTFFCazc3d0V2QTBZQnI0QQpIR3AzM1J5TGNzd0MrcEpMTHZGNDgya2k4aWtSdVRBT3pHa0EzYXIxNDJpNXRCY1dKb0VCbGtrU0FXaTAxbVhnUFZyclF5THlGYURTCjdubzYxdVNZb2h5WFhISUpnTjh1dTFCRS9rWXA5V2RLS1RNSXhqZytHeFhIQzR1akhtbk1kM0Vkd2podDNTejRGZ0R0UDdwL3p3T2YKTGhRSzM2NVdxL3JUbi81MHU2dnVtSkZqRXRDdVppNEM3eE9SVHl1bHV2MmROWDhuTUVsYmg4VnBoVU1ubWZFZzJTN3RmYUJKbG80bwovaHdDYUlBSGdRK0p5SDFqWTJOMGRuWUM4TWxQZnJMZDFkaFdPYVlveDkxMzM4MGxsMXhDbzlGUWhtRmNKQ0x2VTBwMVI1bm1rdWhIClZKdzA0RTVqanc2QzJEL3dFblpNSzFHYTJYK3V0VjZsdGY2QWlHenI2T2g0dnQxMWQ2eklNUU5vejk2Y3krV29WcXNuaXNpSFJPVGsKSkd0RkZOMkk2eFRHRGJ5RURjSWtVWTdnQ0tKM0huWk1ramk2QWM1SXFRdG9FL2dqNEZIZ0g0SHh2L3FydjJwM05iWmRWTHN6NEJldApOUk1URXlYZ2JTTHk4amgrbkFhOFliL2o3TlJoTnV1NDhMRGZRWnQyMFA3dEQ0dTZublQwM2RNbEl1OFFrUXV6MlN5Zi8vem4yMTJGCmJaZGpRa043OHpTMDFrcWNsU1YvS2lLWktDMlpWa1A3TzRCcExCOXA2RWRZZmlDOE05anFTR0dNRFhvU2Z3NW82MU9BUDJrMEdvOHEKcFhhMXV5N2JMY2RFcC9DeXl5N0R0bTBCZXBWUy82U1Vlb3Rub3ZNRE1tNmtMdzJ2VGp2Z0V2WEJUTmN3ZUp5a0FYSXdUR3Q5UUd2OQpFYTMxRDdUV2RZOENmZUlUbjJoMzFjNjZIQk9VNDVlLy9DVXVnRjh0SXE4U0VSVUZxQ1NRcHVYVmFlelhRU3FSOUNHRjBaQ3dEekdLCmJzUlJtYmk0U3FrK3BkUTdsVkpMYzdsY3U2dXpyWEpNVUk1TEw3MFVyZlVDbHc5Mng0RTBqSDYweXJYajdqc2FFMTVhVzNUd2R4TFYKOEk1UmZ5S0NiZHNYYXEydnRHMzcrVUtoTU5Gb05OcGRyVzJSdGdQNjRvc3Z4cklzTVF6alNoRTUwNitkMHdEUml4dkZsZE5vNDFhSAp3c1BpUVB3Z2kvYzdUa0pHQmtPdEhQN3JudFVEeUdtdHJ3WitCbXhzMVZUNFlwRzJBZG8veHhtWW81UjZ2V2R6anV2NEpZRTlTb1BICmFmRTRRSWNCTzQxTk9vNUQrOCtUSmljRi83eVZLd0h0N0IzUEJGNXVXZFpXSEpjSmYzRFNkZzJ0bEVKcmZiR0luQkhrem5FZHNpaEwKeFZSNGRScEFwNkVnY2JURGt5ak4yWXFGSTRKeWFDQUh2RjVyL1IrV1plMXJkOTIyUTlyYUxsMTIyV1ZvclV0S3FhOG9aNzVHTnN6MgpHOVVCQzRiN2dablVrVXRMUWFJR1hlS0FEVk1IZE1wUlF2OEFTL0QzUWEzMXU0R2ZtcVpwQTd6Ly9lOXZaelhQcXJSZFE0dklhU0p5CmxvaGs0MnpEY2Fhek5EdzRMZDBJQ3dkU2R4U2pxRWZ3UEVxU2dCeWtHaUh4T3JYV1Z3SS9COGJiWGIrekxXMEQ5R1dYWFlacG1saVcKZFk2SUxHbWxlWS9Tb2ttY2VhcThPc2xHSGRUSzNrY1ExU2tNOG1aL2VCeUg5c0k4SUl0STg3Y1A0S2JXZW8zVytqaXQ5Vk4vOFJkLwowYTRxYm92TU9xQXZ2L3h5d09tdE54cU5YcVhVdVNMU20xYnpSWUcrRmZOZEhQZU80OCt0YUdsSVR6dVNadGtGTFJzZWtJTmdkbzlpCjIvWWljWnhUUGpYYjlkdHVhZHZBaWd1T2swVGsxS1NtT3dwNGFlNXBsV3FrSFFTSm11TVJGcGJVSjRpYkJ4SVdKMFcrTzVWU0Z5cWwKekQ4MFY3MXRvUncrRFhXS2lDeEthczZEVFhnWUJVaWppZFBhdCtPMGZwSnRPc2t1SFNWcEIxVDhOQ05JUTN6bGxIV25seTRFdG43egptOThFNEpwcnJtbEhkYytxekxxRy92blBmKzVWUUJFNFdVUjZva0NRMW56WEt1ZE9ZL0ZJYXlXSmlodWxlWlBTU0RQVW5pWTlFUmtRCnh4bFB1ekUycTlJV3l1RUNwMDhjLzgyWkpCREdXU3ppdEdTYU9DSVNhL0lMK3hDU3dKZUdIcVNoTVdrL2hJZ1BwMU1wZGJKU2l2ZTgKNXozdHh0bXN5YXhUam5QUFBkZlR4bk5FWkdFUzJPSzRjUkw5aU5QS1NmSFNtQVBUZkN3UVArUE9veENlaEpucmdqUWpMSTRuUHVwUgoxRnFmWU50Mjl0dmYvbmJ0RDRGdVFCc0FYU3dXVVVwaDIvWThZQ0NzOHRNQU93NDhhWGh1V3VvUjl3R2svUkM5ZlBtUFFVa2FVUEdzCkdGSDgyWjhQeTdJUWtTeHduRXZwOXN4MlBiZExaaDNRMld5V1lySEkyTmpZZ0RpN1VLVXllVTNGbXBFV3VLMkN2QlgrM29yWkxzNEcKN1Flelo2YUx1c2Q3akR1RHNSLzRiMEJQdDdqYnFRRXdNakpTVUVvdEVuZmpIaUFSckduL29nQ1dwck9ZUkRQU1dqMjg4K0I3ZVJJRgphTzg4YkJBbGJPYWRIOWplZVlCK2xHM2JuaWNpajg5V1BiZGJacTFUR05CV0pSR1ozd3BRZzFyUm4rWlVQb1EwM0RsTWM4ZDFFc1BPCm8rYWl4SVhGcFpGazJ3NjhaNGRTYXE1U2lxOTk3V3Z0eHRxc3lLeHA2SUJXeW90dmREQ0taNllGWkJnSW8rNFBBM0JTbkZhNGRSS1gKRGltTFZMUHJnaHJZYjNlT2NsWWp6dWFodlVvcHVycTZacXVxMnlwdEFiVGJZU242cjdYU0VmVHVhWlY2eEgwRXJRQTNEUmYzOGhuTQpjN0FzSU5aVndhVGZmb29Sak8rQk8zQXRDNVNWVXBobTIrZWh6WXJNK2x1NmxXbmlhT2tqTkZlYUR0VjA4dTdwN0RBbVBUdjRMbjd4Cmc5cnJBRVpwWnk4ZFA3aTl6cUtYQnpldW9iWE85L1Qwc0hmdjN0bXU2cmJJckFINmpqdnVBT0NQL3VpUEFBeHg5dEdPTlcrMXlwSEQKTkhnYzRMeDRhVHFNVTdGK1FMUTNwVENKNnhCQ01zM3d4SXZuT29qUDdkNjkyOGhrTXRaczFYVTdwVjBhV3VHQXVoa1dwbmw5OFRrYQo4TWRwNWxZK2xyUURORW1jUGt6QytMT25xWU9XakdCOFA5M3crOUZUU29uVzJsUktLUkg1YjBEUHBJZ2pMVk1JTDE2YWdaVzRhM0hwCnBPWFFYbGljTjlNazZwRm1tWlVYUDR3L0ExaVdGYW01UFcwZDVOZ3ZWbW1YaHRhZXhvanJNTVZwWS85NXF4bzVURHZIV1Q2aWJNNSsKTUtjZFJReVVBM0FrcU9Oc3o1NEU2WWQvdE5DbnBiV0lXQ0ppeDFHZEY1UE1HcUJmLy9yWEErRDZpMmdBVllnSHBTZHBRSjJVVnF2YQpPWXBMeDMwZ2NiYnNzUGZ5U3hqVjhOT05NTTdzQjdFWHg5Y2hSR3V0UmFSNnlpbW5XSnMzYjU2dHFtNnJ6QnFnQXozMGhvaE1CQ3MzCkxURDk4Wk40ZDFTOE5COUVLMXc2amRVakxHOWhOdWhnWnpCSU44TEsxbnVXMzlvaElwWlNhdUw1NTUvL2I4b3gzZUpWanF0QjZ2Z1cKY0laVmVQQThHTlpxSjNJMnFFcmF3WmFvOG9reTA4VU1uSVRSRFAvdm1vaU1Hb1pCdmY2SDRhYWpYU09GRXlKeUtJNVgrc09TQURjZApsQ1JxTGtjYW9FZWxFMHd6bUI5UHdzeDEzamxFVXd2dlBPYTlLbHJyZzdadE4zZWhmYkZMdTZ3YzR5TFN0UFNIVVk4b09oSWxjZG82CjZYb3IycnlWa2NNNEUxNVFvcXdhL3ZoaEhUOC9zSVBnVmtxTjI3YTlEK0JOYjNwVG02cDZkbVhXQUgzcnJiY0M4THJYdlk1OSsvYU4KejVzMzcza1JxWXBJRHNMQkZjWS9vMERudng0Vk53NndVWG53Zm9kUmpUUkFqK0xpbmdRbjV3ZUh1SVBXakNpYUVmRTNMQ0s3WjZ1Twpqd1daZFExdDJ6WURBd1Bhc3F5ZE9IdFpEM2pYNGpoemxLVFJ6RkhOL2RIeTZ5aWFrY1NuL1hrTURua0hoN2c5Q1J0QVNRSHEzU0t5CmY3YnJ1SjB5NjREKzZVOS95aHZlOEFaY3piRUwzNnFWSkluVG9LM0dpUU95UDE3YWVTRnBoOC85endKQ3VYT2NPUzRwRHo3S1VoT1IKNTVWU2d6TmRwMnZ2V1UrcFVXREVITXRyUWRtaUs2TFJGMTE0d1V3LytnaHAyeUpaRWRrbkl0dkRya1hFajd3ZUZoNEY4ckE0YVNoSAoxUFVvKzNTVTFvNWExQm9XTjZyRG1wSk9WVVJrczJFWWxUVEtZcXF5ZHQxNnFyVXFZL25LY2NwUTF4cEtmU0tqakZWbTFsUnIxNitmCnNlZEdTZHVHdnJYV0I1UlNtOFVaTVRRZ25EN0VTVlM4dUxDb3psa3JvRStyc2FNb1NGQkRwelhQcGUwVHVNZFJyZlhUbm5iL3hTOSsKd2N0Zi92SnBxNysxNnh5dzJyWk5KcC9KQWEvTzVzeS9VVW9LdFdxOXYxR3pQaU1pKzd4NDU2ODViOXFlSFNkdHM3YjM5UFNNaU1nVAp1SHRXcCtIS2NWdzRLVTdZTTlMdzU3RHd1RHdsZ1R0cVY2d1d0VzlzZWJueDlvaklFek05b09Ma1F4VFFnVkFVUVdta0M4VFVSNXY0CkZHVFdOZlNiMy94bUFFWkdSZ0NlQVhZQ2ZWR092OU0ybDNGVUpJMFdEL3RBb3M1Ym9TUlJWaEF2WHRBTmdmLzk0ejZ1aEx6V2djZVUKVWx2aDhDNWoweW1leGwyN2JqMWFxd3JZUDZ2WHJDVjE2TlhvYnlOcUh5S0FmWFFQYWxIYXBxSGR3bjlhUko0T3U1YVdkc1NrUFdWSgorcGlpQU9YUHUzY2V4YkZOMDR6a3oxRWZTOXlIRkRnZkU1SDdSS1FXMkNsaDJ1WDhOZWVobEEzSVU0MkcvZGVOaHZVUlcvTWJqZDNJClp4UloweVE3aTZ0bFpsMUQzM0xMTFFCY2ZmWFY1UFA1UGJWYWJRUHdDcUM1NkMxdThucGFhVlhEQnlXT1drVEZqN3JISHhhMGVIamkKK3RKbzZaa3hzaFBZY05TRm1GSmNiVzBCQjladmVBQVFBNlc3TGEwTEF1TWFSdGZmLzRCMTNqa3ZuZkc4dEUxRFc1WkZyVllEdUY5RQpkbmpoYVR0NTB5VlRBVTd3WTBuQloxT1pEWTgyN3k2RmFZaklneUt5S1p2TmN0OTk5ODFZMlFWbHcvMzNvMFJud2I0QzlML1l0djZaCnJmVTN0TmF2UUpOMXdENnowallyeHc5LytFUGU4cGEzb0xWK1ZFUWVGcEdUY2EwZFFZblQyRE1KOXFSbnhsa24vSG1QNHNoeGFjVGQKRXhkSFJNYTExbmNwcFNwYWF3Rm10RysyYm9QVEVEUnFEYlFOV3JoUWEvMTVZS1hiUlZnaElpOEIvUUdRZTJZeUw5QkdEZjMydDc4ZAowelF4VFhNUVovdUVnM0M0TXhRbHdXdFJZQXFDTGtxaXpHWkovdWJTU05RS0ZOdTJtMzlSSzFUOGVRaWJKeDBSUitOMEJuK3RsTEl1CnVPQUNmY0VGc3pPNGtjbGxFQ1VsNEpYQXFmbDhodTZla3VUeUdVTnJmUUx3YXFWRTNmL0FiMmMwSDIyZkpPczJsYjhBbnNDblRaSTAKVzV5MHlzR2o0cmZ5ckNSZ0JzRnNXUmFXWlNVQ08rb2ppNUNxaVB3SW1MVWwzbXZPUFJkdGE2eUcxV0hiOW11MTFwZHJNRE1aZzJJaApTeVpqZ0lPekxpVVlhb1liMUxZQitudmYreDdmKzk3M3ZBN1M4OEJ0d0Nna2Era3dpV3VPVzJtKzA2WVRwclhETkhId2R4REkvdk1vCllNYzlLNUNYcDRFN0xjdWF0Y25QN3NCSldVVGVwN1grQW5DV0FKV0pPb09EWTB4VWF1Q3NVTnJ6OFgrNHRYN1dhWXRuTkQ5dDE5RGYKL2U1M3ZUMzJiaU9ncFNGK1Y2aGduQ1JKNHFCcFBCaWx5VWNVdlFocTV5QzRvNEFkM0dQRi96eGZXQVA0ZDYzMVp0TTBaNXhxckZ1NwpuZzMzcmdmSG1jMXJnSThCUzczOE5lb1c0K05WR2cwTElHdmI5c21mKy9Dcis5YzkvTnlNNXF2dGdIN25POS9wZWZYWkFueVBGcllpCkN3TmtHS2o4Y2VOQUdIWU1lMmFTSnZhSGhZRTFET0JCTUFlQkhmYU1RSDUrQjl5YXkrVm1aeXMzZ1lrT0FQcUJ0d1B6QVpRaFpITW0KdVZ3R3d6UUFRV3VkQVM0RUxwbnBiTFVkMEQ1cEFQOE8zSzIxdHJRUFVYSGFPQTNYaklvekZmQkdoZnVCR0thZC9kbzRxSjNETkhYWQpNNk0yMndSR2dHOXJyWit0MSt1Y2YvNzVNMXBSYTlldEo2Y2hWMEVCeTRGVjRQU0hjcmtNNWM0ODVlNEN4V0lXWlRTcFl4OXdybExLClhMZCs1a3prYlhkNDl1MXZmeHVBZDczclhXaXQ5NHJJTjRBenRkWUw0b0E1VlhOWU1Dd052VWpTL0dIZzlzUmJ1QXFIaDdyRExEVkoKbWozQkV2SnpFYm5UTk0ySjJWcHFOU0VJSURoQTdRSlFJbVF5QnZsaUR0TlVhRnN6VWFsak9jUGZHV0NPYmR0NTNMN1NUTWl4cEtFeApUZE1DN2dGK2lEUHkxTElXRGJ1bmxjNVY4RnBZM0tST1lCZ1lneDNCSkE2ZFJEOTh2N2RwclcrcVZDcWJiZHRtelpvMU0xNVB6c2lnCjFzNGZvMEFGUUtPeExVMjkzcUJXYTlCb1RGcXNZQUhEWU5kbTBqVGVkZzN0eVkwMzNzaTczLzF1eHNiR0JqczZPcjRGdkJRNEY1STcKaG5IWGsrSUU0OGFCMVQ4cUYxenY1NGszdkIzMGN1VFh6bkVhT282MmhJQjhBcGVtRll0RmJOdG0vZnIxbkhmZTlFN1ZYTHZ1ZmdBRAo3RTRjYld6aWFHZnRIdmNEYzJ4Yk0xR3R3N0JHbEdxQzJwVUpZQkRVQUdCNjAwcHhaaStOSXh4Q21Eai8zS1BMK3pIblR1ZWFhNjdCCnR1MnNZUmh2VmtwOTBUQ01nYWpOS01QQzRxWm5SdDBmZG95YTZobU1FNXdhbXNhRFVwakU4ZkdJVHFUV1d0K3B0ZjVMNE1senpqbG4KMnV2Q0I3b1NjRDd3S3VCMG9OTVh6UUE1R1hTM0Y2QmNZN05qdkdwS0RkaUVzK3pPNExDYWJnQTdnTFhBWFJoc0F1enp6NWthc0k4NQpRQU84OTczdlJXdmRvNVQ2bUZMcXcwcXBZaHlBNHdDZUppenNkMXhZSEpEakFBMnRPWnBKc0pROHFiWCt1R21hdDFlcjFXbW5HajR3Cjl3THZBZDRQSEQrRDFUNkJNMko4WFQyVCtiVmhXZnJDYzF2L1NJOHBEdTNKTjc3eERkeTFjUCttdGI1RGEyMjNZdnVOc2dlM01tRFIKNmwrcnBya3cvcHlHVTd0L0I3WFcvMnJiOXMvcjlmcE04dVlDOEE3Zy8rVXdtSFhncjFYUkVXbmtnU3VCVDJicTlWWEtudG84Nm1NUwowTmRlZXkxYWErcjEraVlSdVI2bk9Zb0YzNlFTUzhtZmsrekpZVmFHcEE1ZkdIampPb0pKd0E1SmExeHJmYVBXK2pzaVVqMzMzSE9uCnZmeGQ3YXh3ekhGL2dXTnI5a1FDZjYyS3hLUmg0TmlyM3c0VWZhMUVhamxtT29WKzBWcGpHQWE1WEE2dDlYcmJ0aitudGY1N3JmWEsKbzlHaVh0ckJqcDUvRDhDb3ptRFF0NXcvTERpMzJaOVcwcXFUdUk4c2hIclViZHYrQVhBOXNIOG13T3lURE01RW8rWEJDL1lVdGVlUgpGUTJpQkZIaTEvVjVIRkNmRER5MGZ1MDZBTTQ3UDEwcmRFd0MrdXRmLzNyei9OcHJyN1cxMWo4SFB1LytMY2QxckJrR3ZEU1dpcml3Ck5IRzhzS0Exd3hQZjNPUlFWMlhCOHlUYTR3SzZvYlcrRGZoYllPZU1ndGtFR3VTQUZUaWFXZ09pdFdab2FJamg0V0gwZEZqZXRDYVgKejlQZjMwY21rL0czdFBPQVJRZ1BxYXpHcnFadkNJNUpRUHZsaGh0dTRJTWYvR0FEK0xIV09xdTEvdDlhNjJXNG9IYktKUjRRY2RmQwpRQnVuallQaUI3V1hscjh6R0RUVnhWazV3dkxwZ3JtdXRmNHA4Q21jS1FKczJMQ0JHUU4xQTNEbWFIVGhVZ0lSb2RGb01Edzh3c2pJCnFHdUZkc3RFbXY5U2lIWTBzMXNtNDVVS0hSMmw0S1pHZWFBRVFxT2lPZi9DOUNPZnh6eWdBZjdwbi82SkQzN3dnMVVSdVZsclBhRzEKL2h1dDljbFRBYkRmM1d3Y3JRaGVqeE9sMUJGZTlPUGNmOFhONlE0QmN3MzRvZGI2cjRlSGg1L3Q2dXFhOFVuN1N0bll0dEpFckhEVgpXdFBUMDAxdmIyK3puTklCK3JBSDJ0SFJVZmJ0MjQ4ZHJ1b3RvSUVOZHE2MXZMOGdBQTBPcUQvd2dROVVNNW5NclNKUzFWcC9SbXU5ClFtdHRwTkc4YVdoRThEcWtCN2IvZ3docTVqaFFoMWxzZkozUWNlRC9hcTMveHJidExlVnlXYlRXV2luRlROaWRQYW5iR1F5c0JvR0oKWXA2SjB0YWF2cjUremx5OWltS3g2SVRaeVVZUDc1MHR5MkxUcHMwY09IQVEzV2lnNUFqYlJBT29JYnJsYnVjTEJ0QUFYL3ZhMS9qbwpSejlhMDFyL1RFUkdnRTlvclMvU1doZWp3QXBFZ2p4c001NHd6ZTJKNTJvckNPd3dyaHpsczhPVHFCVTF2bnp1Qm00Qy9oSFk3azRICm5SVlhGNFl6NjZDT013S29BZVc5WXlaallpakZqaDA3QU0yYy9uNFdMMTZVYW1QUGVyM083dDE3MkxsckZ6dDM3cUplcjVQSlpKeU8Kb2ErK2NIWjNxQUNvaHNIYTllczVQK1hvNXdzSzBBRFhYMzg5SC92WXh4cVdaZDJ0bE5vRmZBQjRxOWE2UDY2VGwwWWpCMmxIVktjdgpHTzd2QUtZQmQ1ajRQajRMZUF5NEFiZ0ZHSnpwMlhNUllnSFA0dENPcG1lcllxbEVmbVNVU3FYQzAwOC93OGFObTlpN2J4OXJ6anVYClFxRVFtWmh0MjJ6ZHRvME5HeDVnZUhnRXBRVFROQ2tXaTJReW1XRDBZZHdsZWEzS0N3N1FIL3ZZeHdBd0RFTXJwWjV5K2ZSbXJmVTEKV3V0VDRpaElVQ1A3TzRGaElJMHkyWG5YSVZ3N3A2VWJudmpBWEFIK1UwUnVxTmZydnhLUitzVVhYOXl1b3E0REQrQm82UVZlUGt2RgpJdlBteldWOGZKeEtaWUxSMFZGMjdkckZvVU9IWWdGZHI5Zlp0WE0zUTBORGRIWjJVQ3lXeU9XeWRIUjBZSnBtc0tWNkhtYzR2T1UyCjZaZ2NXSW1UTDMzcFM4M2haZGRldlU5RXZxRzEvcC9BVFZyclF3bXoweEpYaUVUWWdHTUhUdUpHQXkzTG90Rm94SjFyMjdZZjExci8KcmRiNkU3WnQvMmNtazZtYnBqbXJiZ2c4c1FFMUR4dDRFcmpYZjAxRTZPenNaTzdjdWZUMGRIdXV3S2c3bTBGRml0WmdhMGRCRkl0Rgo1czZkUTM5L1AvbDhQaGoxQUhBM043SWJjV2IydGVJWDd3V25vUUcrK01VdlR2cjk3bmUvZTJ6bHlwVy9QSERnd0ZNNEZYQ04xdnFsCnRtMGJhVHArYWNTdndiM3pNSm9STlpnQzRXNTBSV1FRdUUxRXZnWDhWbXM5NXRkWUYxNTQ0YXlYcndDL2ZSYk83T0lBbXU4REYrRHoKNCsyOW8yR1l2bnZTOTk2OHpxVy9IRnp4cGcvZnhydEl6WnY5OG9JRWRGQys5YTF2QWZDcFQzMXFKMDVIYXIzVytzMWE2NnRzMno0SgpaOWRhQ2V2NHRRSndmOGNsT0hnU05OWDU0NFR3WisxMmF0ZHFyYjhML0FyWUE5Z3o0WWV1VmJsZ3pYbXMzYkFlTEJvSXZ3UytCSHdjCmwzcEFhKzRjZ3VMWXNJKzR0dzc4R3ZoN1RYNmJVSnRTMmk4NHloRW5uLzNzWnpFTVl3SjRIUGdINEIzdWtQa1R0bTFQMk02Y3kxVHIKL0tMb2hJNlp1eEUxYWQ5M3ZXSGI5cUJ0Mi85cDIvYUh0TmJ2QTI3T1pESzdObTNhWkJ1R3dhOS8vZXQyRjZNakdxY3JhRElNL0N2dwpWV0JzT3BJTzZSZmJ3SHJnNHdvZU1KalE1NitabWxueVJhR2gvZUl1UWRLV1pZM204L21IY0hqZzk0RXJ0TlpYMnJaOUd0QXRJbmx2CitEeXU4K2RKMkZJcS96UlJQeDBKYU9pR2lJd0RlMFJrcllqY0JxeFZTdTIzYmJzQk0rTWRkRnBFNDh5RUhtSUU0WEUwdzI3SWRJdG4KVVhuQ0J1dG9mRW0vNkFEdGpkYTV3TkxkM2QyVjRlSGhKN1hXVCtNQSt5emdJdHUyendPVzRJQzdLQ0taS0RPZEowRWcrK21HajRKbwpjVFpER2hWbmw0TEhSZVJlNEY0UmVkb3dqSEhiRWE2ODhzcDJGMWVrZVB4MTdmM05HVyt6MFpycm8zV00vcUlEOUdjKzg1bEp2ei8zCnVjK0JNKy9EMGxydlZrcmRibG5XWFlaaHpOVmFuNjYxUGtORVR0WmFMN1Z0ZTY1U3FxeTFMdG0yWFFSeXVJTUtFZmJsT3M2ZWkrT3UKQzl0QkVka3BJaHVWVW85cnJSOXl6MGNBYlJoR0UveFhYSEZGdTR1cVZXbUgvL0tXNVVVSDZLQjg4cE9mREF0dUFEdXZ2Lzc2bmZWNgovYit5Mld4SmF6MEhXS0NkMWVielJHU2UxcnJYdHUyeVVpcG4yN1lKS0tXVWJkdDJUVVRHbFZLSHROYjdnZDA0N3JkMkFydHQyejVvCldWYnRxcXV1YXZmci84SEppeDdRWVhMOTlkYzN6dzNEMEIvNjBJZEdjVll2UHdmd2xhOThCUkdSWXJGbzRzd0x6aHFHWWJyMmI5czAKelhxcFZLb09EQXcwK3ZyNjdFcWx3c2tubjl4TTA5dVQwVHYrOFIvL2NidGYrUTlHL2lBQi9kR1BmclI1ZnQ1NTUwMWFKYjErL1hvKwovT0VQZzlQRTFsZXNXRkczYlh2Q05NMThKcFBKbXFacEtxWHlobUhrbFZLV1lSaDFFWmw0K2N0Zlh2L0ZMMzRCdkdnQmZFeXVQdzNLCkh5U2d6ejc3Yk85VTZ2VzZ6bWF6Z0RNOHUyYk5tb0xXZXA1UzZqZ1JXU2dpQzRCNUl0SXZJaVVSeVlxSXdyRWwxM0ZtcEIwU2tUMlgKWDM3NWJxWFVEdUI1RWRtSjQ5SEk5czFWRUVELzlLYy9iWGNSVEVXbWpVTkhtSytuSmYwL1NFRDdCa2ZFTUl5TWJkdHpnTk5NMHp3RApPTTExdmo0SEtBSjVjYlp2Tm5GNit1TGVpb2hvRWJGeHB6dUtTQlZuZjhCRElySkpSSjRRa2Q5cnJYOHZJcytKU0FPd1gvdmExK3JnCmhKei8rSS8vYUhleFRCSnZQWisyQllXTjFtSVM0WkMrTlFsMTVTQkFSdHVpN3JuN2Q3enNrak9ublBvZkZLRFBPdXNzY0F0UFJMcEYKNUF6Z0VxMzFCU0p5SW82L2laeUltT0pJODk2dzBUODNqZ0pNRWNuNzRod25JcWZoK0xHbzRFeTBlUUJuUkhDRFVtcTdaVm0xL3Y1KwplM0J3eGpkNlBUclJHaHNwQzV5TjQvYkxLeEIvSk5JcjJOQVJXUU5ZS1VxZlpPUnFqeDVOZGwrMGdGNjllblh6M0FXYTRDekxQdzY0ClZFVGVBSndCbEhFQXJ1TG1YOFRObHZPTDc1cmgycmVMSXRJcklpOEJyaGFSVGNBZEl2TFRnd2NQUGlraXc0QjE5ZFZYTjlPNCtlYWIKMjExOG5ML21QTmF2VzA4Tk1CM25NcS9GcjZHMVptSml3alZEcWtuek9zTExCUXpEY0RvbTlScU5ScU01bjhPdG14T0JxMEdlWEx2dQovb2IzZ1p5L3ByVmxaaStxb1crL1BQVFFROWkyemZqNE9EalU0VXljK1FqZkVaRXZBWmVMeUJ3Y2pheUNJSTF5OHhXMmNqdHNxbWpnCkl4QWNMZDRwSXF0RTVPTWk4ajAzSDFjb3BlWnFyWlZ0MjhjRW1NRjFlQU9ZMEEyOEVUak5YdzYxV3MxZExLdnA2KzJscDZjN05yMU0KSnNPY09mMFVDM25HeHl1TWo0MEg1M09VZ0Q5MjZtbnFxOHBmRUQzWFZzV25uWFBBUzBUa1N1QXRJbks2aUJoeEswclNYSXU3SnlxZQpkeDR5T0xOYlJHNFhrWnRGNUhmQUFhVlVzNlovOElNZnpIcjVlZnhaUkVScmZSSHdUUUplay9idjM4L2V2ZnZJWkRKY2VPSDVMRisyCkxESGRrWkVSMXE1YnozUFBiYUc3dTV1QmdRVmtzMWsvc01lQnJ3T2ZCS3BUR1RWODBWQ09GU3RXTk04dHkxSktxU1VpOGxyZ0xjQ1oKZm83cmx5UUFwZ0YwOEw0d0NidnUvcDZQNDJyclV1QjJFZmsvd0VQQWhHRVl2UDN0YndlY0xUeG1VeHFBcVhVWDhGWjhZQllSSmlvVApEQThQWTlzMkN3Y0dHQmdZU0pWbVIwY0h5NVl0WS9mdVBZeU9qakk2T2twUFQ0OC9TaEc0QXZnSnpzeTdsdVZGQStoSEgzMlVsU3RYCklpSWRJbklKOEM0Y1d0SFZDa2pUU05KcWxGYWU1WFV1Y2Z5Ti9BV3dCdmkrVXVxSFd1dHQzLy8rOTl0U25xYkRsODhCWHVjUDExb3oKTkR6TXhFU1ZmRDdQaVNlZFFNNDFlNllwdDRFRkMxZzRNTUNtelpzNU5EUkVxVlR5SEFwNTBVNEVyZ0llV3J0dS9iQVhtRlpidjZBQgp2WExseWttRkJad2tJdThFcmhLUkU0TGNPQVd3SmwwTFd4c1lKV0hhdDFVcUl5SW1jTGFJbklBRDdIOTl4enZlOFJ1dDljUk5OOTAwCjI4VmJCdjRNeCtsTE04L2o0eFZHUmthd0xKdGx5NWF5WVA3ODFJb0FvS09qeExKbFM5aTladzlqbzJPTWpJeVNuZnhCWkhGMkZ2NnAKaU54bG1pYjFldm85a0Y3UWdJYW10MDdUTk0yTGdJL2lXRENLL2pncHRlUVI1OEg3bzlKS3E1WEQ4aE1VTjZ3YmVJT0luS2ExL2hmZwpPMjk3MjlzT1pyUFpwaytPRzIrOGNkckwwdWRMVGdFWDR3Q3JhWXF3Ylp2aDRXR3ExU3FtYVNEQTVzM1BUZXFKYVJ1eTJReno1czJsClZBcWZhVG93TU1EQWd2bHMyclNab2FFaE9qbzZ5T1VtZ2ZvazRBMWE2d2ZyOWZyK0YvMFNMRGlzblVXazF6Q01Qd0hlTHlLbnVGb3UKa1U0a1VZNDB3RTY2SjQ1emgrVWpFR2FLeUtraThpa1JPVlVwOVdYYnRwOFJaeUJuaG1lKzZYNlFkK0t6T3p2YWVaeVJrWkVtUFhoMgo0eWFlM2JpSnliWUZaMmJpV1dlZHlhbW52Z1RUT0hJc3BsQW9zSHo1Y25idjNzUFkrRGpEdzhQMDkvZjdUZHVDNDFmdmRnUHJKL2V0CjI5Qjg1UXNTd1AyQ0FyVFg4Zk5WL25IQWg0QjM0dmd4YnJxdFNob1VDWk8wSFVBL0ZRbmtoN0RuQitPMHFMbDdnWGVJeVBFaThyY2kKY2g5TWNYMVNrcmd1ckxIbGxUanJDSnZ1Q3l6TFluaGtoR3ExZW5oTm9QWWN3VXgybHFPVUltT2FzU2EwQlF2bU03QndnSTNQYnVUUQpvVU9VeTUzazgzay9sMTRHdk1IQytLMmdkNlg5Z2w4d2dBNnhZcnhFUlA0S2VKT0k1RnB0L2x1MVVuZ1NCOHkwMUNidW5yQzBYUXZOCnhTSXlGL2ljVXVvbjExeHp6ZGczdi9uTjZTMWtCelVMY056Wjl2a3ZWU29WUm9ZZDdYelNpU2V3ZE9uU3BxZitTVWxveUdSTXVydTcKL1FNblIwZ3VsK09FNDVlemMrY3V4c2JIT0hSb2lMbHpjd1NxNEZYQXJRcCtvc0ZlazRKNnZDQUdWazQvL1hTMDFsN253VkJLblE5OApHWGhyRU15ZXhOR0RxUUE5amhPSFBTOU5xNUFDeVA3ckJzNDhreThCN3hXUjdqLy84eitmdGpKZXUyNjlONEw5T3B4aDdpWTJMTXRpClpHU0VTcVZDVDA4UEo1MTBJb3NXTFdUQmdnVkgvQTBNTEdEdTNMbkJqbDZveko4L244V0xGeUlJdzhQRFRFeFVndVUwQUZ4dHczd3QKd3RyNzFpYW1lY3dEK3ZUVFQyK2VWeXFWREhBNWNMMklYQzRSSTN4cHdCeDF6MVQvd3RKT3E4SERydm5EQTljWEFwOFdrUThycGZyZgorOTczVG1keEg0OHpLamlKTzFjcUZZYUhoMUZLc1d6cGtxYnRPTzNISGlXbWFYTGlDU2RRS2hXcDFXb01EUTJGemZONEZYQUJ0bTB1CldiaVFleE5BZlV4VGp0Tk9PdzJ0TlFjT0hLQy92ejlyR01hcmdiOEdWb2dqa3dyV1h3bEpCWjVXNjBhRnBhVVIvdnZTZGo3RDRydC8KWGgraEc2ZnZrQk9SZjN6Zis5NjMyKzkwM2U5Zk80MnNXN2NlRTFUZG1hOXhGcjVlbm1WWkRBME5VNmxNTUcvZVBKWXNPUzdNZGRlVQpwYisvbjJWTGwvTG9ZNDh6TWpKQ1oyY25IUjBkZmk3ZEI3d0RrZldidDI5L1BpbTlZMVpEcjFpeG9ya0F0YisvUHd1OENmZ3NEcGliCitVNUxIYnl3c1B2aTBnbTZ4ZlZMVXVjeTZqbHBuNS9RbW5UamJPVHpDUkZaR0hRbjNJcG9vQTZuNHN5bDZQVmZHM2V0RUxsY2p1T1gKTDZPM3Q3Zmw5T1BFTkUxT09PRjR1cnJLVktzMWhvYUdDZGs4OUNMZ01zTXdNbkc4SEk1UlFIdWMyZTB4bXpqTjRLZUFVeVZpVmh3awpnenNzbnZjN21FN3dtSkxudHZUUnBFa3Y0YjI2UmVUUFJlVGpTcW41U2luKytaLy91YVd5ZG0zUFdad05leVpOUkxZdG0wTkRROVRyCmRUbzZTaFJMUlFZUEhXTGZ2djNzMjcrZi9mdjNzMi9mZm9hR2hqaWFIV3g3ZW5vNC92amowY0RZMkNqajQrUEJPdWtFM29sbVFaTEIKOHBpakhCN05hRFFhWkRJWkEzZ044RmNpOHBLMG1zNHZyWUF6S3QyMFdyUVZmaDBWUCsxMVgxaW5pTHdIeDVUM2Q5ZGVlKzNCRzI2NApvZFZpUHhWbmlMdnNEeHdiSDJOMFpCUmxLQ3FWQ2c4OTlNZ1JlZFJhazh0bE9XUFZTbzQ3N3JncDFibGhHQ3hidXBRdFc3ZHlZUDhCCmhvYUdLUllMR0ViVEpab0N6a2I0WXh5dnJKRmZ6ekVGNk5OT2E4NVFSRG1rOEhMZ2Z3R250d0xtVmpWZDNQVTBZUFZmRDVNMDFDYnAKUXdyTG8wODZSZVI5SWpJaEl0ZDk0QU1mR0RJTWc2OSs5YXVoK1Fuc0xsVUUvZ2huNTk2bVdKYkY0T0FoR2cwTDBFeFVxMVFxRTgydApZejNSV3BQSlpCZ2JHK2RvcEZ6dTVJVGpsM1B3NEVIR3hzWVlHeDJuM0RYcCt5b0JmNksxdnV2Zi91MWJ6M1IwZFBEbU4xL0ZSejd5CkVjQloyQXpIR0tBZmYveHhUME9MVXVvODROTTRNK1VrQ3NTZVRJZm1UTnRMVCtMSWFVRGZLcGhUZktCbEVmbWZJakp1bXVZL2lVaW8KMjY1MTZ4MHdWN3RIeUJ6cVFMU2Nna1BwY3Y1MFIwZEhHUnNiSTVQSnNHelpFbnA3ZWtMNXVjYXhLUzlldFBDbzZ0NDBUWlljZHh4Ygp0MjVqMTY3ZERJOE1VeXdWL2E1MmxZaWNwcFI2NDd5NWMvN2gxYTk1amZXRkwzemhpQTdxTVFYb1UwODlsZEhSVVRvNk9rN0JtUk83Ckpnek0vb0pQMHJwUjhmelhnbW1uNWI1Snp3a0xEejR6N0hyYTlFTHU3Y0taejdJUHVPa2pIL2xJMWJ2bnkxLys4cVMwc3djN0VhRlQKdyt0eFZ1NDAwNnZYNnh3NmRBakxzcGc3ZHk2cnoxaDFwTzluNy9udVQ4ZnJsRWJRazJpdVA5OStkMmthamxndFd5cVZXTDVzR2Z2Mwo3V2RrWkpUT3puSEs1YzVtR3RWcXRUd3lQUHpXKysvZjhPakZGMS84OU5hdFd3ZXoyZXlRNTFMTm41KzJpOGVkUldTUmlId1crRFB4CmRRRERLdDQ3VDdzZFJLdWMyTCtkY2RMOTN1K3dlNUtlMVdwZVk1NmwzZDhibFZKL0tTSS8wMXBiWHJ6cnJydU90ZXMzZ0FnTjI4WjAKcG9mK0c3N1ZLQUNEZzRmWXZYczNBQ2VkZENKTGxoeUhJSWdTbENoM0N3bUZVb0lnemxFRVp3R3NQeVhubm9uS0JEdDM3bVJ3OENDNQpYSTQ1YytaUUxuY2hUYmZFTnRxMjBjRHcwREJQUFBFa0J3NE8wdHZiellJRkM5QzJ6Y1pObTNqNnFhZll0MjlmbzFJWjMydWE1cDV5CnVmeDRxVlQ2VWFsVSt0WGl4WXNIOC9sOCt6VzBuemVMU0Ivd1Fad1JRT1d2dkxCS0RkdndNaXArcTJDT295RkorVW5ia29TMUZHSFMKQXVmMjdOVEhBLzhmc0s5WUxLNnZWcXVUNmNJNVQyQ3VQN2tNOG1aQ2xsWWRPdVFNY0pUTFpaUlM3TnExdTdudnVmUG43WEZ1b2tSUQo3bThsenRGVGswcUV3VU9IdVBPT08vbnRieCtnVnF2UjI5dkw4dVhMT2VPTU0xaTRhREVpZ3RWb1lOa1dEY3Z4MXRyUjJjSHd5QWhqClkrUHMzNytmUjMvL2UrNjU1eDRxbFhHNnVyck1ycTZ1Z1VLaE1KREw1VmJuOC9sWDVQUDViNHlOalgxdDd0eTVlNlpoV2ZxMGdGbHcKT055N1JlUXZjVG81VXdaazNEMUJIODUrN1I0R3lPQTlSOXNDVENYdlNlbUZ0RkFpamorUnVaWmwvUTQ0ZU4xMTF3Rnd6VFhYd1BaKwpCWEkyRHEzcjhkZkpvVU5EREEwTkl5TDA5ZmFTeS9uMlZkTU9uVEJOQTlNME1Rd1RjeExRUGJBNzU1WmxjY2NkZDNETExjNDZ5ZDdlClhycTZ1dHhkczJ5NnlsMlVpa1duOXZWaElCaUdRYTFXWTN4OG5JY2Vlb2k3Zi9WTGJOdWlwNmVIenM1T1NxVVN4V0tSVXFsRXFWVHEKS0JhTHE0dkY0cUZHby9Id3NXS0gxamlyUy80SGpqZlExSnc0RElCcHRhOWZ3OGZ4NmxZQmxoYk1ZYytkU25vUllvcklLMFhrV3NNdworajcrOFk4N29hVU9RRW80RTVDTzg2ZGZxMWJkcFZVV0lzTFE4REE3ZHV4aysvYnRiTnUyalMxYnQ3SjU4MloyN3R6WjNKZFJLWVV5ClZCUFF5ajFtTWhuMjdkdkgzYi82RlIwZEhmVDE5VkV1bHltWHkvVDA5SkROWnFsVXhySGRWZU9pUE1YaExLanQ3dTVtWkdTRVJ4NTUKQ0lET1RtYzJudmRYS0JRb0ZBcmVlYmxZTEw2N1dDeXVhQ3ZsOEt3YXdFcWNGZG5IdTlvbEZiQVNLdlFJOGNlTjRzZGhBSXBLcTlYNwpXZ1dyLzFxd1BLTFNDN3hYVVVUK1JHdTlTVVQrOWNwWFhURmhqNHdvcGRRYUFtNEp0TllNRDQ4NHJnbkFuUzQ2M05TY0htR3hMWXRxCnRjYUNCUXN3bEdwT0pXMkMyMjB0TXFiQi92MzdHQjhmcDd1N200Nk9Eam83TzV0LzVYS1piRGJiekx0dEswUnNoNnVMc3cvTDhQQVEKdFdxVlVxa1VCUENrYy9kNFFxRlFlRTFiQWUyQ2VZR0lmQlE0TDRrM0oybElMeXlLT2tTRnhZRXVxU1dJQTNJckxVMFlUMitCTzhlVgp5enpnTDBSazB3VVhYWGluYVJoZHR0WkhMSzJxVkNZWUhobkJ0bTFLeGFLN2d1UndoMC9FNlJBaVFuZFhGL2w4dnFtZGxWdm1obUZnCnVJQTJESk5zTmt0WFYxY1R6RUZRbDBvbHgxZUh0bEVpMk9KMElrVTduY3ZxeEFTWlRLWUpXaitZQTMrNlVDZ1loVUpoWmRzQWZlcXAKcDJMYmRsWXA5YWZBYThWeHQ1VllXZjQ0WWIrbml6ckVQUytwbFVqN0xQL3ZwR3RKSDBBd1RpRHNWT0Rhc2RHeFRTTHlFclMrREovSgoxcmJ0NXZUUVRDYkQzTGx6S1JUeWgwRnFHSWU1c21tU3orVVFFZXFOT2prajUycG9COHlHWVNEdWNmSGl4U3hac29ScXRkb0VjVWRICkJ4MmRuWFNXeTVSS0hSaUdvdEhRNEwyWGF5bnhkbHNPYU9Fa2NCZmJBbWl2TXlnaWw0cXpxTFUzcW5LaktpME9BSzF3ejZrQ0tpb3YKY1hsUHc1K0Q2YWE5TCtrajFWcS9vcU9qNDhQVldtMXBKcFBwODI5K05ERXgwVnhhMWRYVlJiRllhTklId3pDYW5VRFR6R0RiTms4Lwo4d3pQUHZzTXRXcU5nWVVEbkhiYWFTeGV0S2hKTnp3dFBYLytBaTY5OURMV3JWdExxVlE2ckowN091anM2Q0NYeXpXM2VrTWNzNTkyCjdEUW9wWnhPWTZrVXA1bURRTjh6YTREMm0rZGNPVkZFM284emFUMjJ3Z0FhalViVCszMDJtMjF1R084dCtURk5NOVllSFFSZkdOaWkKbnAya3dkTnEzQ2h3cDJrdGt2S1hKQ0tTbXpkL3didkVXWFBaSEY1ekZyNDYyam1menp1bU9sR1RadTVwN1EyNDFMajMzbnU1N2RaYgpxZGZyOVBmMzA3dTVseDNidDNQSkpaZHd5aW1ub0pUaC9pbXlXWVB6emp1WFlySEFqaDA3bXVsM2RYZFRLblVnU3JBYnR1UDlzdmtuCjN2NlRMRnkwa09lZTI0d1NDUVd3NzAveStmeG9McGU3cDEyVW80elR5MzVsa2tadE5CcjA5dlp5empublVDNTNZVmtXRHovOEVBY1AKSG1UTm1qV1V5MlZxdFJxUFBQSUl1M2Z2eGpTUGZLVTBnRXZTdkVsQVRnSnpFbEREd0RxVjlNT2VwYldtczF4bXdZSUZCZjhlaUE1MwpyamlkUDZDcnEweWhrQWVoMlRuenAvZk0wMDl6NjQ5L3pQajRPQU1EQS9UMDlORGQzWTFsV1d6Y3VKSDU4K1l4ZDU1SHpaMFBvbEFvCnNIcjFtU3hmdnB5SmlRbVVNc2htTTJpZ1lUWGNtT0V5TUxDUTQ0NDdqZ1A3OTRkYU4veDBKSnZOUHBUSlpQNXJWZ0R0clRxcDErc28KUjE0bUluOEdGT09hYWFXY1dWNXo1ODdsbW11dTRZUVRUbUJzYkl6cnJydU9CeC84TGU5NHh6dm82KytuVWEvemxhOThoUjA3ZG1DYQpabXBPM0VwbnJSVnVHOGZ2NC9JU0IrUzQvS1dnRy9UMDlOTFIwVEVwSGN1eUhNdEdaYUlKamtiRGNsdkN3enQvS2FXbzFXbzgrdGhqClRGU3I5UGYzVCtyY2RYVjFvWlJpYUdpSXZ2NStEQU5zKy9DMjB5SlFkdWxEdmRGd2RzOXRXSTRMTzgrS29pY1BtZHUyVGFsVTR2UVYKSzNqNnlTZHBXQmFGZ3A5UEh3WjBKcE5sb2xyZE16bzJQanhyR25yKy9QbnMzNytmZXIyK1ZFVGVCeXhMMjB3cnBXZzBHZ3k1YzNPVgpVbzdwcDZ1THpvNU9iTnRpOGVMRmVKdnlwQjBJaVFKYkZDRGo4anBWMEVXQlBpcXZyWDQ4b0RGTWs2NnVyaU1tOGxTclZVWkduRUVVCjI3WTVjSEFRSlllTzJGeTBvNk5FVjFlWjhiRnhjcTdsd2c5b3I3T0hPRVBxM3IzK1BTRXRkeFRRcTA5dGFKUjI2OHZqMFJDZ09wcTUKYytkaG1pWjc5K3hCYTV0Q0lVK3hXS1JRS0ZJb0ZEQU1nNGxxbFZxOWRwTFdlczZzQVBxeHh4N3pUb3NpY2hYdzhqU2c4djZVVW95TwpqdkxjYzF2SUYvSXV4ekxKWnJMazh6a3N5K0xjYzgvbGtVY2U0WmxubmprQ2hFa2dTd3Vlc0xUU3BoOFZMK3I5d3lUdGZmNEJJNjBoCmw4bFFMQmFiSVBOa2ZIeWNhcldHaURQa1hhM1ZEcHNYbkx2UnJ0dmNZckZJZDA4M1BUMDlBZlBiNGZOOG9ZQnRXVFJzUjhNZnpwdEMKbEtaUnQ2aU1WNmpXcWpRYURhYzFzRzAwdWhuUEd6NzNyeTNzNjNOYWhNSEJRY2JHeHJBczIzSGZLNHFKYXMyTHUwQ1E1VE1PYU0vOQpnR1ZaU2tUT0ZtZUZSVEZOczMyNHdweXZ0V0ZaMkpiem9wV0pDdnYzNzZNeU1ZSFZhR0RiTm1lY2NRYWJOMitldEVGbUhFQ2lwRlhOCkdqV0hJd3FJU2M4S0N3K21INmVaL1hHMTFwaW1TVGFibVFSbzI3WmQvODZRejJmZFRlUjlZOUJPS29nSXhWS1J6czRPamwrK25EMTcKOWxESTU0L1EwRjFkWFJSY1FHdXhVZTVTcWJHUlVmYnUzY09XclZ2WnNXTUgrL2J1Wld4c2pFYWpnWWhnbWhrS0JTZTk3cDRlZW50Ngo2ZXJ1cGxBb05KZmdPWXNJOG5SMmxoa2NIS0pSSDZaWUtwR2Q3Qk92Q015Yk5jcWhsT29EcnNWeFNwaFlvWk1yeXB2SkpXNlpheHIxCkJzTWpJKzRYYW5IZ3dBSEhCcG9DRUZOcHlzTUFGUVd3dU9la2YrZGt6cDJXTm5uYUx5aTI3Zmd0S0JhTHpKMDdONnJleUdZem1HYUcKWmN1WE16WTJ6dDY5ZTd4NUZIUjBkRkF1bCtuczdIVG5hRGphZWYvK3ZUejIyS004OE1CdmVmcnBweGdmSDI5YXFqeVRvR21hWkRJbQptVXlXVENaRExwZWpXQ3JSMCszTXNsdTBlREc5dlgwWWhvbHQyODM2YlZnV2pVWWptRlVES013NG9OMHZ5TVJaNHZOS2lmSFBuSzVDCkhadWxCM05IT3g3bVhFY0RnbURjcE90eDRXSHBwSW1UNW1PS2VxK3d0TDE1eW8xNmZSTGRjTFNqVS8zMWVnTVFNaG56aUVuOG5rS3gKTEl0OHZzREtsU3ZadDM4L3RhcExRN3A3S0hkMWtYSDlQQjg2ZElpSEh2b2RkOTExRjA4Ly9YUlRFMmN5R2JMWkxObHMxclZwbTRGSgpUYzZFcFlsS2hiMjFHb2NPSFdMSGpoMHNYTGlJcGN1VzBkUFQ0M1FtM1RrazVwRTdCalNBa2RuUzBNdUI5NGpQdFcyU1pvdXJSUGNpCnBtblNWUzR6TmpZNnFTT1ROcjAwdjZQU2pBTlZNRjRjR0pQeTJtcmF3VHc3SGVvNmxZa0paK3E5eXlwRWhNNk9Eb2FIaHhnZEhXWFAKbmozMDlmV1N5V1FtdFhSd3VLT21iWnQ4dnNCeHh5MTJOYTB6Q1NtVE1iRXNpMDBiTi9HVG45ekd2ZmZlUzcxZUo1Zkx1ZGN6a3dEcwpuL2R4ZVBER25IVDBMRnhidGp6SDRPQWdTNVl1QWNTMWZoVEpGL0xCNGh3QmRzNElvRDB6blF1eURQQ25JcktTd0NyenRKMjBVQURoCk5LTzVYSTdLUkNVV2NGRWdTQXVlcUdOU2F4RDMzRFQ4UHE0bFNIc1VjV3o1dzBORE5Pb05NcGxNYzAxSnNWU2t0N2VQQXdjT01EZzQKeU9qSUNIblhOQ2J1NEFyb3BrMWFSTnpKL1Y2L3dabnJZVmtXejIzZXpKMTMzc0d6eno1TFIwY0hoVUpoRWppREFHNE9xZnZpK0k5KwpnRmNxNDJ4NjlsbEtIWjMwOWZYVDE5Zm52TWZrMW1RVDZLZG5WRU83emNnYWNTd2JIVkVWbWxpcElXR0liKzhsWjUzR0VkTkIwendqCkNpeHgxOUxRa0NRdG51WURpOHB2bW52ODE1VlNEQTRlWkdSNG1ONitmcS9BVUVxNVdqbkwwTkFoeDZ2Ky92M3VuR2NUUXhsSFVCQjkKdU1BUmNiVC9ZNDg5eXJxMTkxR3YxeW1YeTBkb1lqOVE0N1IwMURYVE5GR0dRYTFXcFZJWlIrc2p2Q3MxZ1A4RU9UZ2pnSDdzc2NjNAovZlRUc1cyN1MwVGVnVE10TkxiQ1lyVnppdWE2WHE5UnFWU2FGZGlxNWo4YURaNmsyVnY5b0ZwNVZ0b1BaMnhzakYyN2R0RlpMay9TCmJvWmgwTlBUeGZEd0laNTUraWtPRGg2a1ZDelJQNmVmdVhQbTBWbnVKS3hENlpSNW5kOCs4Q2dQUHZBQTRLd0pUQUpxR0xpVFBnQi8KK1BqNEdOdTJiV1BwMHFXVVNrMFBTdzhDUDczampuUEhaZ1RRUGsraGwrSk0zTS82T1YwYVlNZHBiV0NTMWpaTWc0MGJOL0xJSXc4Zgo4WXdvOEtRRlNSVGZqOHAvVk5wVEFXc2NVT09lRTVadkVXSHYzajEwZDNlellPRkFjNzRHd1BQYnRuSG5uVDlqKy9QYm5SVWxTakUrCk5rYTFYR0ZSMXlMSzVmSVJlYkZ0bS92djM4RDZEZXVZcUU2UXkrV09BR0VjVUtPT1lTQVBobzI3SCtlaVJZdko1L083dE5aZkI1NisKOHNvTjA3dW1NREFCYVI3TzFoREh4WFd1b2lvMFdBaUEyOTQ1bGd4bEdFM0ZyVVN4Yjk4K3RtMTdubUt4ZU1ReXErblFySzJtbGVaRApiUlhvd1h1U3l0RXZTaW5xOVRwYnRtekJ6SmpNbVRNWDB6UVpHeC9qL2dmdVorTXp6ekozM2p4NmUzdnA3dTZtcTZ1TGJDNUxvMTVyCnJrVHhWbWtycFhqMm1XZTQ4NDQ3R0JzZGJkcU0wd0l5TGJpak5Md0g2Z01IOW8vMjk4LzU1Kzd1N2g5VnE5WHF1ZWU4ZFBvWHlScUcKd2E1ZHU1Zy9mLzdMY2JZMVVLMVdxRzNiakk2T0lpSWNQSGlRa1pFUjhMb3lXamM5VldwYk8zc2dvS25YNjFRcUZTekxpZ1JJMkVmagpWUkRRdElXMkNxd2s3ZDRLUnc3S1ZHaFRsS1oyTEFmamJOcTRrV3ExeHNEQUFrWkhSdG03Wnc4ZEhSM055ZmlIUndMTHpXM1h0Ry9ZCmVuRHdJTGZmZmpzN2QrNmdXQ3lGYXVLMFd0Zy9VektKaGdUVEdCMFpvVEkrUHZqOHRpMFR0cTI1NmFhYnBoZlFqei8rT0N0V3JHRCsKL1BsTHhObXBkVkhhQ3ZYQ3ROYVV5MlhPT2VjY2Q5MVpoYVZMbDlMWDEwZXhXRUtVY09LSko1TEw1ZWp0N2FGVTZpQ2J5YkpxMWFxbQpqVE1LZEdIUG50UnhPampJOWgzYm14OUY4TU5MK2hEanJpY0JORzZWVGRpejQwQWY5YjdlZWFWU1ljdHpteGtaR1c0T1VIZ0xVTDFCCmtzN09Uc3J1SEEzVE5OMUpSb0p0V1R6NDJ3ZDU4c2tueU9YeWlhQkxvMzNqNHNkUkdCSHBVRXE5VlNsMWI2UFJlS2hRS0V3UG9NODQKNHd5ZzZVakUyM0Rta21EbGhsVnlzTUsxMWd3TURQQ2U5N3dIY2VjOE8xK3dRYjNSQUsxWnZYbzFLMWV1UW11YSsrVzk5Snh6V0hYRwpHUzYzOWlZU0pPWDhjSVJDb2NDbWpjOXk4ODAzTXp3ODNMVEZIZzJ0U0VNRjBuRGZxVkNjSVBpRGNTM0xZdisrZmRScU5YSzVISVZDCllkSjZQOSt5cVFuYjFzOVhMYXRxR0liZXZtTkh6NzMzM2pQZnNpeXp1UXdyQXB4cC84TFdKYWJoMSs3ZnVVcXAxMlV5bVkyTlJtUDYKQmxaOGhYY2NqbHZXL3JqS2lxdVlURFpMSnB1bFVwbWcwYWhUcTlVbitVN3owaGdiSHc5N2ZzdmkrV2ZMNS9PVHRsRkk4eEZHZ1RRTgowRnZwQktiaDhFbGxISmEvVENaRFgxOGZsbVUxNlladjhsRzlXQ3orY21LaSt0ZTFlbjBVTUw3NzNlLzhqOTI3OTd3N204MmFyUURUCi96dllSMHBEVjhJNmwrNmZZWnJtNjVSU1A2clg2NytmRmtBLy9QRERyRml4QXEyMW9aUTZGN2dvaVgvR1ZxalcyTFkzOWZEd3pDMC8KQU1OQWVUU0E5azliVEtNMTB3STlMVVdJZW03WWZYRmhTV1Vjdks2VW9ydTcyM0h3NHM3TGNHbUhYU2dVSHN4bXMxKzBiZjNnVlc5NgpvOWJvbHhRS3haT3oyV3pPNDcydFdpazh6cHhHWThkeDZjQ2d6RXJETUM0cGw4dlBUQXVnZlZ1c3pjZlpYNjgvcWpLVEtpT0pRODYwCnhPVWhyU1pNK2lDU25nL2hiaGFpbmhXOE53ckFVZVh1K2RId3BtM1dhalgyN2RzM3NYZnYzdTkyZEhUY1p4aUdMam8yNWpPVVVpY0gKd1p3MFlCSjJqTEpYdDhLbmZmZWFobUZjTGlLM0hEV2dWNjFheGFKRmk5aTJiWnVobERvSHgrNmNTanRQcGNKbld0SzBKbUVBVEVvcgpMUy8ycDVtR1BzUTlLNWpIcExxb1ZxdnMzNytmQXdjT29MWE9hSzNQVVVyZDlKM3ZmR2RZS1ZWU1NwMWhHTWJjSkRQYzBkcVprMEFjClFWRk9Od3pqaEdueG5IVDc3YmQ3MDBPdkpyRGhUTm9tTUt5QWo0Wkd0Q3doczh6UzV0TnJ1cWZDaTZkU0xrZkR3YU91ZTJFZTlSS1IKakZMcTVTSnl2bXM5bW1NWXhpbEtLVE5wU0x0Vk9wRms5VWp6VVppbU9kY3dqTlZIQmVoVnExWjVSd05uTzRQTDRwcTdscHJQMllQeQpFUTlNeTVIRHdxWUt2dEFzaGR3M0ZUOTdhVnFic0RoS3FibEtxVGZkZlBQTkdSR1pvNVJhbU5RSlRETXFtRWJycHFFMGdYdnpobUdjCk1WMVdqZ0lPZCs2TEEzRlNCOG83TjAyVHJxNHluWjBkTkJwV1pJVlBsMml0S1phS2pBd1BoNjRhRHdOM0VrRGkwZ2llUXp4blRpT3QKYVBrVzNpRUx2T3kvL3V1L1ZvdEl0MGMzMHBqcDB2RG5WaWhKRk1EZGE5b3dERkZLTFpzeW9EM3RqS1BiVm9qSUsvR05Dc1lWWkZLbgpSV3Z0cmc2MnNLd0dNNit2TmFxaTNOVVoyVVJndGRJQmpKcFhFaFcvVmM2ZDlFR2x1VC9obmtYMWV2MjFoVUxocVVhalVZcmhzQzN6CjRsWUdYeEpBTHU3dm8xK0NKWTdqa2pmZytLaVRPRTBjOXRzTDg0NWFhMnl0R1JzYnAxS3BORmM4ekJ5ZmRuek9sd29GR28wR2ZsOXUKYWFoUzhCM2lycmZTbndoN2JsU1pobDJMMC9MQjYvNXB0eUZwbExUV3J4d1lHQ2hzMjdaTlR4V29hYXdYYVRsMVRKcmxLUVA2a1VjZQo4VVlJVHdHdUVKRkplK0dtcVp6SXY0aEttQ254VDY5TjJ5RnI1YjFpd0pMNDhhUjVYdHl3ZVZKcll0dDIwN0lCME5YVlJWOWZYM0FMCmloUG56Sm1UMjdWclZ6YUtNa1IxNE9MbU9zZng4RGd6WUF6NGpTa0RldlhxMVFDaXRYNmxpQ3dSdDZUU05Hdkoyc2tCOVV4ejU4UDUKbWZTckpSNmF4RWVUdEh5d1hNTEtLZTcrcUg1SVV2bDdOdWN0VzdidzFGTlBZUmdHUFQwOUtPV3NBc3BtbllXcjd2MWRwVkxwMUh3KwpiM2lMVllPREkya0E1eDJEcTFUaXRIVFNJRXZnZXExbFFMdEE5bVMraUZ5QnN6RmlhbTRaRFN6dlB1ZjNMQnJ0UXZOeVpMNGtGVENECjc1c1dpR0hQaWkrbmRLT1hVZWtPRGc3eTVKTlBZdHQyMDd0K3VWeHUrbU1XRVkveXFXdzJxektaRFBWNlBkWWlrV1NwaU5QQ2NUYnQKRkdscXBkU2hLWnZ0M0lsSUYrUHNJUmlKMUZocUVRWDh0dTFsbEs2amxlYmQwc1JQbTA1U3F4Qk1KM2d0TEYydE5mdmN5VW5lVER1LwpBeGx2Q055TG44dmxtcFA0cDZKWjAwNFBUY09qUThLMFlSaGFLYld6WlVBLzlKQ3pSWUJTcWdONGhUZ2IvVFNic2FTS1Rhb3dFV21ECkVkcVh2NUNIeDcxWEVsZE4rekduQVh0Y2VuRmxIRlVYalVaamtpc3ZiNWFkMzllR3g4L3orWHh6OFVTYzdUaHBCTEZWTFp4U2s0dXIKb1RjZXpjREtHU0x5VWlEVGFnVW1hNXYySUZyY2Y2MEFNd3gwUVdDRm5RZkRvdUtuNWN4VEFicm5zem5NdzM1SFIwZlRoQWtPb0RzNgpPbHEyVXNUTnFHdEZXNmQ0N3BoaEdBKzFET2pWcTFkN2JyMHV3WFc0bUZTSVlaVVhkdjF3UEJkZHMwMmlKUjJva2tBVXZNOXZpMDVxCnRZTFBpWHBXVW43aTd2VmEwLzUreHlWQUdOVW9Gb3VNajQ4M3phV1pUTVpabHVYdWk5S0s3VGpKZXBIV0xwMFFiNGRTNnNIVW5jSXoKenp5emVXNmE1akxnUWhIcFNGdUl3V3RSbFJGVjZiTUJacTlsaU5QQ1FTQ0dKcFh5M1krR3hvVGxLVzBkZU5lOWZRaVZVazBnZTdSagpaR1NFQXdjT05PL3pyQ0RGWXBGcXRYcFVvM3R4L0RwdG1rR3dpOGlEU3FudExXbm9pWWtKRE1NQWgyNjhKSzVBMDFSTzJzN1VyRWtMCmRDTnFxRHF1RE9MQUZxZHA0OEFlZFo2bS8ySzZiblk3T3p1YnBqcmJ0dG16Wnc5YnQyNmxYcTlQU3F0Y0x0UGQzUjA3MkpHV0xyU28KZlpQaWpDcWw3aklNWXpnMW9ILzN1OStSeitleExLdFRSTTRIRmdZTEtxNUMwbFpxMjBFZEFZSmdXQmg0V3VIWlNadzdycHpTWGsvVApiL0ZBVWExV09YRGdBTTgvL3p5N2R1MmlXcTFPaXVkNEFNMHhiOTY4NWc1WVlRTWZjVk5Ka3l3V2FkS01BUG82cGRRNjI3YnJxUUc5CmF0VXFyMUJPQU00VjErbGlWQVVmZmFYT0hvbDJwa3pTSE14SnE2V1RxRlFZc0ZvdHB5Z3QzY3I5U2RyZUt3UFBHYUlIOUxBMCt2cjYKNk83dVRtMXVpK3YweFFFMWJPQW1JbnhNUkg1a211WU93ekNTRjhtZWRkWlpnR04zcnRmcktwUEpuQ2tpcDZmaGgwRUphb2F3Q3RCYQpnOWFZYnViOW13WE5GSmhGSE8rWTFlcVJyc1RDM2lIcEk0MENaVmk2VSsxL1JFbGF5cEgwdktqM3krZnpMRml3Z0ZxdDF0eXVJbTRJCk80M3BMbWxHWG9JbS83bFM2aTdMc3FvaVFtb05iUmdHbVV4bWpvaGNDSFRGVlhCWUJjUjFaSUx4RGh3OHlOTlBQVVV1bTZXenN4TnYKbzV2cG5LRGtwWlhMNWVqcUttUGJGcHMzYldKc2JPeUlLYVJwNlZDcldqUHUzcmp3VmpUdzBXcnhzSGZzNit1anY3OC9kVWZ1YUxoMgpBc0EzSzZWdXpPVnlXNVJTTEYyNmxNVE42M2Z0MnNYQ2hRdTlsemtkZUorSXpFdlRmTGJLTFVXY3p0YjQrRGhQUC9VVXd5UERkSFdWCm05NG1MY3M2d21mRzFJRHNqSHgxbEVxQVpzdHp6M0hmdmZmeXlDT1BVS3ZWdkY3enRMNlhQenlzUXpsVk9qS1ZhLzU4eE4zcmdTZ1kKYnBvbWhVS0JhclZxV1phbC9QNmUvWlFnNkFjNkxsNmFZeUQrSWFYVTE1UlMvNmZSYUZTWExsMEtrQXhvZ0lHQkFiVFdXUkY1dFlpOApUWndwbzFNcVhPOTZzS0Q4aGF5VVlxSmFaZlBteld6ZXZKbXhzVEY2ZW5ycDYrM0ZNQXdhOVViVDhVbHJRSVpzTmtkblp3Y2lzR1hMCmM2eTk5MTd1di85K2R1N2NpWWg0VnB4RVFFNzEzYWNicUZFZlJ4ejE4UU0yQ3V4SmY5bHNWbWV6MlFOalkyTUhsVkpsd3pBa0RNQlIKNEE3K1JkMGJjUnhYU3Qya2xQcXExdnJBc21YTG12V2NDdEFMRnk1RW5KWGNmdzZjT1pVS2k5SUdVUVhvVWh4R1JrYllzbVVMbXpkdgpwbHFkWU83Y09YUjNkNE00M2krOSsrUEV0bTFuMytseUdkTlFiSGx1Qy9mZWN3OFBQUEFBMjNmc2NJR2VqUVhIVkxSeEhQQ1BWc3RQCkpTL1QzQUpJUHA4ZnNTenI1b21KaVpKcG12TkN0R2dxclJ1bWdXTStob3BTNnY4YWh2RjNXdXR0ZmpDbkF2VFpaNTlOc1ZpazBXaWMKQm54UTNHVldTVTJhdnpMRHdKeTI4THdwakVORFEyemR1cFdOR3pjaTRtd1QxOWxaYnRLUU1HQjdHK1owbGN2a2NsbTJidHZLcisrKwp1Nm1STGN0cVRyaUp5bnNVR0tJQU8xVnRPMTMzSjMxRWNXbTIrazZBMGRuWitZc0RCdzU4TDVQSm5HUVl4a0Jhd01acDhKQ2pOcHhWCktXT0dZZHlvbFBvNzRMa2dtQk1CL2RLWHZoVERNS2pWYWprUmVSM3dWaEZSVTIyeVd0VisvdWQ0SGNQaDRXRTJiZHJFYzVzM1U4am4KV1RCL1BvVjh3ZGtoeTZVaDNzWTBuWjJPSi9tZE8zZndxMS85aXJYMzNjZnUzYnRwTkJwTlB4UnhsQ0x0QjNpMDE1TzBjUlJJajBZagpSOVZibW5mM3BXMG9wUm85UFQxZkd4NGVYbSthWnI5aEdFdE4welJiQVc0S1RXNGJockZkS2ZVbEVmbXExbnI3OHVXVDlwNXFTcUxaCnpnVkhKODVVVVhPNndCd3NNTCtFaGZ1cGlHM2JiTjI2bFowN2QzTGlpU2Z5c3BlOWpDVkxsbEp2MUtsVUhGL0YrVnlPUFh0Mjg4QUQKRC9Ea2swOVNyVlpSN3YzKzU4Yzlkem8rVlA5ejBvWW41U2NzZjFIcHh0MGJEUGZxTk9sRDl0MnZnTk16bWN6cGpVYmpsOWxzOWlOSwpxYmNycGQ1bEdNWVN3eEZKTzNjNnhOcGhLNlVxU3FtN2xWSTNpTWh2Z05Iamp6OCtFcSt4Z0hZekxjQXlZSFVTSU1NS05RNGNVUVdiCmRJK25SYlRXUFBua2t6ejMzSE9zV3JXSzg5YXNvYisvbjRNSEQvTHJ1eC9ra1VjZW9WS3BURm9oMFNwUTQ4Q1RwTW1pd0pVRThxVDgKdEhJdEtYOWgrWW5LWDBUYVpSRTVmOFdLRmIvWXRHblRGaEg1a2xMcWx5NndYMlVZeG56RE1BcW1hYXE0UVpaQWVOMHdqR0dsMUdOSwpxUitJeUsyR1lld1ZFY3UvSWVkVUFXM2krTnc0WXFnN3FwRGlPb0N0Z0R2TnZkNzhndzBiTnJCeDQwWVdMMTdNOXUzYkdSb2FhbTRsCk5oVUFSWDFrRVdVVUNkcFdQcHc0YlJ0WGJuRjVUZE5DSnVVbktuMzNkMEZFenJFc3EzZk5talVISG5ua2tRbXQ5VHJETUI1V1NuMVAKUkM0VGtaY3BwWTUzclNGNXBWUkdLV1c0SU5aS3FZWlNxdXBxNDczdXZiOFFrVjhiaHJIVHRtMnJWcXR4eWltbmtDU3hnSFpINnZMQQpCUVRtUGFldDRLTnRsc091aFlYbjgzbEdSa1o0OU5GSG00N0xreW83cXVLaW5qc1ZqUmxWRmtudkhQZjh1SHZUdERaSmRkZUtnaEpuCkE1WlRnRk4zN2RwMXo3eDU4OWkzYjU5dU5CcmpobUdzeldReTY1UlN2U0x5RXFYVWljcHhWak5IS1ZWVWp0U1ZVb2VVVXJ1QmJVcXAKSnd6RGVFNXJYUldSc0EwMll5VVcwUFY2WFVSa29ZaWM0Mlo4eWdVWVY3Qkp6WHpVZVRETTJaazBNK24rTkpVZmpEOFZNQ1cxV21uZQpLMjE1cG5sbW1uY1BVckE0a0Nma3ZRODR0OUZvM0FQUTI5dkwxVmRmN2QyaWdRUEF2WGZkZGRlOU9CUTJvNVF5UlVTVVVwWlNxZzVZCjNwN3RSeU9oZ0Y2elpvMlRFNjBWY0I2d3lNbC9PdTBWVmJocEtxeVZ5b3dxOUdEK29vNnRBald1OVVrQzNIU1hTOUl6VzNublZsdlIKa0xRN1JlVHNiRGJiQXd5KzhZMXZiTWE3NVpaYm1yZU1qSXhvUUY5MTFWVTFvT1pkMkxCaGc1ZVdQUGpnZ3hvT3p5RnFWV0kxdEczYgpPYVhVQmVMdVloVlZRRkdGRzR3YjFZdU9Lc2drOENRVi9GUSttbFphaXFScmNlVVNsNWMwNlIvdEIrQXZwN2g3MHJSbzRzeThQRm1jCm1aZ1ArTk44ODV2ZjdKMUdUc1R4YWVXam5xd1RPamxwM2JwMW5rMTN2amc3d0pwSlRWY2FZTVVCSWkyUXcyekhVWlVTZHkxSk0vbm4KTVVTQklRM0FwdElLUmVXbmxYZU1PbS8xTHk3ZFFKejV3S2tBUC83eGo0OFdsMU9XeU5sMmJvV2VDalNkeUlRVlhwUzBBcDZqMFJScApuNU1tejJGeFdzbDNXUDZUd2x2SmE5cXlURklNU2ZVVzl1NUo5U3JPMUlqVmhtSGtSSVRiYnJ1TjIyNjdMYkdzcDF1U3BvK3VFcEZTCkVtQ2lDaTJ1NHNJS01nMUlvc0xTVm5TYXVNR0tUYWpJMUVDZFN0bTE4dkVrdFc3QmZFMzEzU1B5WU9KbzZJVnBsTVpNeWY4UFlTV0MKQkhCamVsRUFBQUFsZEVWWWRHUmhkR1U2WTNKbFlYUmxBREl3TVRrdE1Ea3RNVEZVTVRVNk1qYzZNREF0TURRNk1EQkFORjZYQUFBQQpKWFJGV0hSa1lYUmxPbTF2WkdsbWVRQXlNREU1TFRBMkxURTBWREV3T2pRNE9qSXpMVEEwT2pBd2YvT1N6Z0FBQUFCSlJVNUVya0pnCmdnPT0KIgogICAgIGlkPSJpbWFnZTg4IgogICAgIHg9IjAiCiAgICAgeT0iMCIgLz4KPC9zdmc+Cg==',
            blocks: [
                {
                    opcode: 'connect',
                    blockType: BlockType.COMMAND,
                    text: 'Connect To: [BOARDS]',
                    arguments: {
                        BOARDS: {
                            type: ArgumentType.STRING,
                            defaultValue: '1',
                            menu: "boards"
                        }
                    }
                },
                '---',
                {
                    opcode: 'digital_write',
                    blockType: BlockType.COMMAND,
                    text: 'DigitalWrite Set Pin [PIN] to [ON_OFF]',
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 5,
                        },
                        ON_OFF: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0,
                            menu: "on_off"
                        }
                    }
                },
                {
                    opcode: 'pwm_write',
                    blockType: BlockType.COMMAND,
                    text: 'PWM Write: Set Pin [PIN] to [VALUE] %',
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 5,
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0,
                        }
                    }
                },
                '---',
                {
                    opcode: 'tone_on',
                    blockType: BlockType.COMMAND,
                    text: 'Tone Pin: [PIN] HZ: [FREQ] ms: [DURATION]',
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '5',
                        },
                        FREQ: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 100,
                        },
                        DURATION: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50,
                        }
                    }
                },

                '---',
                {
                    opcode: 'servo',
                    blockType: BlockType.COMMAND,
                    text: 'Set Servo on Pin [PIN] to [ANGLE] Deg.',
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '5',
                        },
                        ANGLE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 90,
                        },

                    }
                },
                '---',
                {
                    opcode: 'analog_read',
                    blockType: BlockType.REPORTER,
                    text: 'Read Analog Pin [PIN]',
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '5',
                        },
                    }
                },
                '---',
                {
                    opcode: 'digital_read',
                    blockType: BlockType.REPORTER,
                    text: 'Read Digital Pin [PIN]',
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '5',
                        },
                    }
                },
                '---',
                {
                    opcode: 'sonar_read',
                    blockType: BlockType.REPORTER,
                    text: 'Read SONAR Trg: [TRIGGER_PIN] Echo: [ECHO_PIN]',
                    arguments: {
                        TRIGGER_PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '12',
                        },
                        ECHO_PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '13',
                        }
                    }
                },
            ],
            menus: {
                boards: {
                    acceptReporters: true,
                    items: [{text: "Arduino Uno", value: '1'}, {text: "ESP-8266", value: '2'},
                        {text: "Raspberry Pi", value: '3'}]
                },

                mode: {
                    acceptReporters: true,
                    items: [{text: "Input", value: '1'}, {text: "Output", value: '2'}]
                },
                on_off: {
                    acceptReporters: true,
                    items: [{text: "0", value: 0}, {text: "1", value: 1}]
                }
            }
        };
    }

    // The block handlers

    // command blocks
    connect(args) {
        if (connected) {
            // ignore additional connection attempts
            return;
        }
        connect_attempt = true;
        this.socket = new WebSocket("ws://127.0.0.1:9000");
        window.socket = this.socket;

        // set up the id string to the WebSocket gateway and assign
        // the pin arrays for each board
        if (args['BOARDS'] === '1') {
            msg = JSON.stringify({"id": "to_arduino_gateway"});
            the_digital_pins = arduino_digital_pins;
            the_analog_pins = arduino_analog_pins;
            the_pwm_pins = arduino_pwm_pins;
            the_board = ARDUINO;
        } else if (args['BOARDS'] === '2') {
            msg = JSON.stringify({"id": "to_esp8266_gateway"});
            the_digital_pins = esp_8266_digital_pins;
            the_analog_pins = esp_8266_analog_pins;
            the_pwm_pins = esp_8266_digital_pins;
            the_board = ESP_8266;
        } else if (args['BOARDS'] === '3') {
            msg = JSON.stringify({"id": "to_rpi_gateway"});
            the_digital_pins = rpi_digital_pins;
            the_pwm_pins = rpi_digital_pins;
            the_board = RPI;
        } else {
            alert("ERROR: Unknown Board Type");

        }

        // websocket event handlers
        window.socket.onopen = function () {
            digital_inputs.fill('0');
            analog_inputs.fill('0');
            // connection complete
            connected = true;
            connect_attempt = true;
            // the message is built above
            window.socket.send(msg);
            for (var index = 0; index < wait_open.length; index++) {
                var data = wait_open[index];
                data[0](data[1]);
            }
        };

        window.socket.onclose = function () {
            alert("WebSocket Connection Is Closed.");
            connected = false;
        };

        // reporter messages from the board
        window.socket.onmessage = function (message) {
            msg = JSON.parse(message.data);
            var report_type = msg["report"];
            var pin = null;
            var value = null;

            // types - digital, analog, sonar
            if (report_type === 'digital_input') {
                pin = msg['pin'];
                pin = parseInt(pin, 10);
                value = msg['value'];
                digital_inputs[pin] = value;
            } else if (report_type === 'analog_input') {
                pin = msg['pin'];
                pin = parseInt(pin, 10);
                value = msg['value'];
                analog_inputs[pin] = value;
            } else if (report_type === 'sonar_data') {
                value = msg['value'];
                digital_inputs[sonar_report_pin] = value;
            }
        };
    }



    digital_write(args) {
        if (!connect_attempt) {
            if (!connected_alerts[B_DIGITAL_WRITE]) {
                connected_alerts[B_DIGITAL_WRITE] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;

            var callbackEntry = [this.digital_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var pin = args['PIN'];
            pin = parseInt(pin, 10);
            valid = self.isValidPin(pin, the_digital_pins, B_DIGITAL_WRITE);
            valid = true;
            if (valid) {
                if (pin_modes[pin] !== DIGITAL_OUTPUT) {
                    pin_modes[pin] = DIGITAL_OUTPUT;
                    msg = {"command": "set_mode_digital_output", "pin": pin};
                    msg = JSON.stringify(msg);
                    window.socket.send(msg);
                }
                var value = args['ON_OFF'];
                value = parseInt(value, 10);
                msg = {"command": "digital_write", "pin": pin, "value": value};
                msg = JSON.stringify(msg);
                window.socket.send(msg);
            }
        }
    }

    //pwm
    pwm_write(args) {
        if (!connect_attempt) {
            if (!connected_alerts[B_PWM_WRITE]) {
                connected_alerts[B_PWM_WRITE] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;
            var callbackEntry = [this.pwm_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var pin = args['PIN'];
            // maximum value for RPi and Arduino
            var the_max = 255;
            pin = parseInt(pin, 10);

            valid = self.isValidPin(pin, the_digital_pins, B_PWM_WRITE);

            if (valid) {
                var value = args['VALUE'];
                value = parseInt(value, 10);

                // adjust maximum if esp8266
                if (the_board === ESP_8266) {
                    the_max = 1023;
                }

                // calculate the value based on percentage
                value = the_max * (value / 100);
                value = Math.round(value);
                if (pin_modes[pin] !== PWM) {
                    pin_modes[pin] = PWM;
                    msg = {"command": "set_mode_pwm", "pin": pin};
                    msg = JSON.stringify(msg);
                    window.socket.send(msg);
                }
                msg = {"command": "pwm_write", "pin": pin, "value": value};
                msg = JSON.stringify(msg);
                window.socket.send(msg);
            }
        }
    }

    tone_on(args) {
        if (!connect_attempt) {
            if (!connected_alerts[B_TONE]) {
                connected_alerts[B_TONE] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;

            var callbackEntry = [this.digital_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var pin = args['PIN'];
            pin = parseInt(pin, 10);
            var freq = args['FREQ'];
            freq = parseInt(freq, 10);
            var duration = args['DURATION'];
            duration = parseInt(duration, 10);

            valid = self.isValidPin(pin, the_digital_pins, B_TONE);
            valid = true;
            if (valid) {
                if (pin_modes[pin] !== TONE) {
                    pin_modes[pin] = TONE;
                    msg = {"command": "set_mode_tone", "pin": pin};
                    msg = JSON.stringify(msg);
                    window.socket.send(msg);
                }
                msg = {"command": "play_tone", "pin": pin, 'freq': freq, 'duration': duration};
                msg = JSON.stringify(msg);
                window.socket.send(msg);
            }
        }
    }

    // move servo
    servo(args) {
        if (!connect_attempt) {
            if (!connected_alerts[B_SERVO]) {
                connected_alerts[B_SERVO] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;

            var callbackEntry = [this.digital_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var pin = args['PIN'];
            pin = parseInt(pin, 10);
            var angle = args['ANGLE'];
            angle = parseInt(angle, 10);

            valid = self.isValidPin(pin, the_digital_pins, B_SERVO);
            valid = true;
            if (valid) {
                if (pin_modes[pin] !== SERVO) {
                    pin_modes[pin] = SERVO;
                    msg = {"command": "set_mode_servo", "pin": pin};
                    msg = JSON.stringify(msg);
                    window.socket.send(msg);
                }
                msg = {
                    'command': 'servo_position', "pin": pin,
                    'position': angle
                };
                msg = JSON.stringify(msg);
                window.socket.send(msg);
            }
        }
    }


    // reporter blocks
    analog_read(args) {
        if (!connect_attempt) {
            if (!connected_alerts[B_ANALOG_READ]) {
                connected_alerts[B_ANALOG_READ] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;

            var callbackEntry = [this.digital_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var pin = args['PIN'];
            pin = parseInt(pin, 10);
            valid = self.isValidPin(pin, the_digital_pins, B_ANALOG_READ);
            valid = true;
            if (valid) {
                if (pin_modes[pin] !== ANALOG_INPUT) {
                    pin_modes[pin] = ANALOG_INPUT;
                    msg = {"command": "set_mode_analog_input", "pin": pin};
                    msg = JSON.stringify(msg);
                    this.socket.send(msg);
                }
                return analog_inputs[pin];
            }
        }
    }

    digital_read(args) {

        if (!connect_attempt) {
            if (!connected_alerts[B_DIGITAL_READ]) {
                connected_alerts[B_DIGITAL_READ] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;

            var callbackEntry = [this.digital_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var pin = args['PIN'];
            pin = parseInt(pin, 10);
            valid = self.isValidPin(pin, the_digital_pins, B_DIGITAL_READ);
            valid = true;
            if (valid) {
                if (pin_modes[pin] !== DIGITAL_INPUT) {
                    pin_modes[pin] = DIGITAL_INPUT;
                    msg = {"command": "set_mode_digital_input", "pin": pin};
                    msg = JSON.stringify(msg);
                    this.socket.send(msg);
                }
                return analog_inputs[pin];
            }
        }
    }

    sonar_read(args) {
        if (!connect_attempt) {
            if (!connected_alerts[B_SONAR_READ]) {
                connected_alerts[B_SONAR_READ] = 1;
                alert('Please connect using the "Connect" block.');
                return false;
            }
        }
        if (!connected) {
            // save this for the reentry
            self = this;

            var callbackEntry = [this.digital_write, args];
            wait_open.push(callbackEntry);
        }
        else {
            self = this;
            var trigger_pin = args['TRIGGER_PIN'];
            trigger_pin = parseInt(trigger_pin, 10);
            sonar_report_pin = trigger_pin;
            var echo_pin = args['ECHO_PIN'];
            echo_pin = parseInt(echo_pin, 10);

            valid = self.isValidPin(trigger_pin, the_digital_pins, B_SONAR_READ);
            if (valid) {
                if (pin_modes[trigger_pin] !== SONAR) {
                    pin_modes[trigger_pin] = SONAR;
                    msg = {"command": "set_mode_sonar", "trigger_pin": trigger_pin, "echo_pin": echo_pin};
                    msg = JSON.stringify(msg);
                    window.socket.send(msg);
                }
                return digital_inputs[sonar_report_pin];
            }
        }
    }
    // end of block handlers

    // helpers
    isValidPin(pinNumber, list, blockId) {

        // is this a valid pin number?
        if (list.indexOf(pinNumber) >= 0) {
            return true;
        }
        // if not, issue an alert with a list of valid pins for this
        // block. Only do this once for the block to prevent an endless loop
        // of alerts.
        else {
            if (!block_pin_alerts[blockId]) {
                var a = 'Invalid Pin Number. Valid pins: ';
                var b = list.join(", ");
                block_pin_alerts[blockId] = 1;
                a = a + b;
                alert(a);
                return false;
            }
        }
    }
}

module.exports = Scratch3OneGPIO;
